import { cookies } from 'next/headers';
import path from 'path';
import fs from 'fs/promises';
import { existsSync } from 'fs';
import crypto from 'crypto';

export interface YouTubeCookie {
  domain: string;
  expirationDate?: number;
  hostOnly?: boolean;
  httpOnly?: boolean;
  name: string;
  path: string;
  sameSite?: string;
  secure?: boolean;
  session?: boolean;
  storeId?: string;
  value: string;
}

export interface YouTubeAuthData {
  cookies: YouTubeCookie[];
  expiresAt: number;
  userId: string;
}

// In-memory store for development, use Redis/DB in production
const authStore = new Map<string, YouTubeAuthData>();

export class YouTubeAuthManager {
  private static COOKIE_EXPIRY_DAYS = 30; // YouTube cookies typically last 30-60 days
  
  /**
   * Generate a unique user session ID
   */
  static generateSessionId(): string {
    return crypto.randomBytes(32).toString('hex');
  }
  
  /**
   * Store YouTube cookies for a user session
   */
  static async storeCookies(sessionId: string, cookies: YouTubeCookie[]): Promise<void> {
    const expiresAt = Date.now() + (this.COOKIE_EXPIRY_DAYS * 24 * 60 * 60 * 1000);
    
    authStore.set(sessionId, {
      cookies,
      expiresAt,
      userId: sessionId
    });
    
    // Also write to file for yt-dlp
    await this.writeCookieFile(sessionId, cookies);
  }
  
  /**
   * Get cookies for a user session
   */
  static async getCookies(sessionId: string): Promise<YouTubeCookie[] | null> {
    const authData = authStore.get(sessionId);
    
    if (!authData) {
      return null;
    }
    
    // Check if cookies are expired
    if (Date.now() > authData.expiresAt) {
      authStore.delete(sessionId);
      await this.deleteCookieFile(sessionId);
      return null;
    }
    
    return authData.cookies;
  }
  
  /**
   * Write cookies to a file in Netscape format for yt-dlp
   */
  static async writeCookieFile(sessionId: string, cookies: YouTubeCookie[]): Promise<string> {
    const cookieDir = path.join(process.cwd(), 'temp', 'cookies');
    const cookieFile = path.join(cookieDir, `youtube_${sessionId}.txt`);
    
    // Ensure directory exists
    if (!existsSync(cookieDir)) {
      await fs.mkdir(cookieDir, { recursive: true });
    }
    
    // Convert to Netscape cookie format
    let cookieContent = '# Netscape HTTP Cookie File\n';
    cookieContent += '# This file was generated by TwipClip\n\n';
    
    for (const cookie of cookies) {
      // Only include YouTube cookies
      if (!cookie.domain.includes('youtube.com') && !cookie.domain.includes('google.com')) {
        continue;
      }
      
      const domain = cookie.domain.startsWith('.') ? cookie.domain : `.${cookie.domain}`;
      const hostOnly = cookie.hostOnly ? 'FALSE' : 'TRUE';
      const path = cookie.path || '/';
      const secure = cookie.secure ? 'TRUE' : 'FALSE';
      const expiry = cookie.expirationDate ? Math.floor(cookie.expirationDate) : '0';
      const name = cookie.name;
      const value = cookie.value;
      
      cookieContent += `${domain}\t${hostOnly}\t${path}\t${secure}\t${expiry}\t${name}\t${value}\n`;
    }
    
    await fs.writeFile(cookieFile, cookieContent, 'utf-8');
    return cookieFile;
  }
  
  /**
   * Delete cookie file for a session
   */
  static async deleteCookieFile(sessionId: string): Promise<void> {
    const cookieFile = path.join(process.cwd(), 'temp', 'cookies', `youtube_${sessionId}.txt`);
    
    try {
      if (existsSync(cookieFile)) {
        await fs.unlink(cookieFile);
      }
    } catch (error) {
      console.error('Error deleting cookie file:', error);
    }
  }
  
  /**
   * Check if session has valid cookies
   */
  static async isAuthenticated(sessionId: string): Promise<boolean> {
    const cookies = await this.getCookies(sessionId);
    return cookies !== null && cookies.length > 0;
  }
  
  /**
   * Get cookie file path for yt-dlp
   */
  static getCookieFilePath(sessionId: string): string {
    return path.join(process.cwd(), 'temp', 'cookies', `youtube_${sessionId}.txt`);
  }
  
  /**
   * Clear expired sessions
   */
  static async cleanupExpiredSessions(): Promise<void> {
    const now = Date.now();
    
    for (const [sessionId, authData] of authStore.entries()) {
      if (now > authData.expiresAt) {
        authStore.delete(sessionId);
        await this.deleteCookieFile(sessionId);
      }
    }
  }
  
  /**
   * Extract cookies from browser headers (for browser extension approach)
   */
  static extractCookiesFromHeaders(cookieHeader: string): YouTubeCookie[] {
    const cookies: YouTubeCookie[] = [];
    const cookiePairs = cookieHeader.split(';');
    
    for (const pair of cookiePairs) {
      const [name, value] = pair.trim().split('=');
      if (name && value) {
        cookies.push({
          domain: '.youtube.com',
          name: name.trim(),
          value: value.trim(),
          path: '/',
          secure: true,
          httpOnly: true
        });
      }
    }
    
    return cookies;
  }
} 